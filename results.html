// ===== types (keep minimal) =====
type Shop = {
  shop_id: string;
  shop_name: string;
  area_group: string;
  area_detail?: string;
  tier?: string;
  time_slot?: string | null;
  best_with?: string | null;
  best_vibe?: string | null;
  status: string;
  [k: string]: any;
};

type Hearing = {
  plan: "explorer" | "connoisseur";
  prefectures: string[];
  area_groups: string[];
  who: string;          // required (slug)
  vibes: string[];      // 1-2 (slug)
  friction?: string;
  no_preference?: boolean;
  source: "hearing.html";
};

type ShopOut = Shop & { reason: string };

// ===== helpers =====
const norm = (v?: string | null) => (v ? String(v).trim().toLowerCase() : null);

function matchesWho(s: Shop, h: Hearing) {
  return norm(s.best_with) === norm(h.who);
}
function matchesAnyVibe(s: Shop, h: Hearing) {
  if (h.no_preference) return true;
  const sv = norm(s.best_vibe);
  if (!sv) return false;
  const vs = (h.vibes ?? []).map(norm).filter(Boolean) as string[];
  if (vs.length === 0) return true; // vibes欠損は緩和
  return vs.includes(sv);
}
function timeSlotMatch(s: Shop, h: Hearing) {
  // hearing payloadにtime_slotが無いなら常にfalse（=優先ソートしない）
  const p = norm((h as any).time_slot ?? null);
  const t = norm(s.time_slot ?? null);
  if (!p || !t) return false;
  return p === t;
}
function stableSortByTime(cands: Shop[], h: Hearing) {
  const hasPref = !!norm((h as any).time_slot ?? null);
  if (!hasPref) return cands;
  const yes: Shop[] = [];
  const no: Shop[] = [];
  for (const s of cands) (timeSlotMatch(s, h) ? yes : no).push(s);
  return yes.concat(no);
}
function uniquePush(picked: Shop[], cands: Shop[], limit: number) {
  const seen = new Set(picked.map(x => x.shop_id));
  for (const s of cands) {
    if (picked.length >= limit) break;
    if (!s.shop_id || !s.shop_name) continue; // 必須欠損は除外
    if (seen.has(s.shop_id)) continue;
    seen.add(s.shop_id);
    picked.push(s);
  }
}

function reasonFor(s: Shop, h: Hearing): string {
  const area = s.area_group;
  const who = norm(h.who) ?? "you";
  const vibe = norm(s.best_vibe) ?? (h.vibes?.[0] ?? "local");

  const whoMatch = matchesWho(s, h);
  const vibeMatch = !h.no_preference && (h.vibes?.length ?? 0) > 0 && matchesAnyVibe(s, h);
  const tsMatch = timeSlotMatch(s, h);
  const hasTsPref = !!norm((h as any).time_slot ?? null);

  if (whoMatch && vibeMatch) return `Best for ${who} + ${vibe} in ${area}.`;
  if (whoMatch) return `Fits ${who} in ${area}.`;
  if (vibeMatch) return `${vibe} vibe pick in ${area}.`;
  if (hasTsPref && tsMatch) return `Reliable ${(h as any).time_slot} option in ${area}.`;
  return `Local daily staple in ${area}.`;
}

// ===== Explorer selector: 1 area -> 7 (S0..S3) =====
function select7Explorer(areaActive: Shop[], h: Hearing): ShopOut[] {
  const base = areaActive.filter(s => norm(s.status) === "active");
  const picked: Shop[] = [];

  // S0: who + vibe
  uniquePush(picked, stableSortByTime(base.filter(s => matchesWho(s,h) && matchesAnyVibe(s,h)), h), 7);
  // S1: who only
  if (picked.length < 7) uniquePush(picked, stableSortByTime(base.filter(s => matchesWho(s,h)), h), 7);
  // S2: vibe only
  if (picked.length < 7) uniquePush(picked, stableSortByTime(base.filter(s => matchesAnyVibe(s,h)), h), 7);
  // S3: relaxed
  if (picked.length < 7) uniquePush(picked, stableSortByTime(base, h), 7);

  return picked.slice(0,7).map(s => ({ ...s, reason: reasonFor(s,h) }));
}

// ===== Connoisseur selector: 4 areas -> 7 total (min viable allocation) =====
function select7Connoisseur(areaMap: Record<string, Shop[]>, h: Hearing): ShopOut[] {
  const areas = h.area_groups;
  const picked: Shop[] = [];
  const perArea: Record<string, number> = {};

  const score = (s: Shop) => {
    let sc = 0;
    if (matchesWho(s,h)) sc += 2;
    if (matchesAnyVibe(s,h)) sc += 2;
    if (timeSlotMatch(s,h)) sc += 1;
    return sc;
  };

  // 1) min 1 per area
  for (const ag of areas) {
    const base = (areaMap[ag] ?? []).filter(s => norm(s.status)==="active");
    if (base.length === 0) continue;
    const sorted = stableSortByTime([...base].sort((a,b)=>score(b)-score(a)), h);
    uniquePush(picked, sorted, 7);
    perArea[ag] = picked.filter(x=>x.area_group===ag).length;
  }

  // 2) fill remaining by global score with cap 3 per area
  if (picked.length < 7) {
    const pool = areas.flatMap(ag => (areaMap[ag] ?? [])).filter(s => norm(s.status)==="active");
    const sorted = stableSortByTime([...pool].sort((a,b)=>score(b)-score(a)), h);
    const seen = new Set(picked.map(x=>x.shop_id));

    for (const s of sorted) {
      if (picked.length >= 7) break;
      if (!s.shop_id || !s.shop_name) continue;
      if (seen.has(s.shop_id)) continue;
      const ag = s.area_group;
      const cnt = perArea[ag] ?? picked.filter(x=>x.area_group===ag).length;
      if (cnt >= 3) continue;
      seen.add(s.shop_id);
      picked.push(s);
      perArea[ag] = cnt + 1;
    }
  }

  // 3) last-resort relaxed fill (data shortage)
  if (picked.length < 7) {
    const pool = areas.flatMap(ag => (areaMap[ag] ?? [])).filter(s => norm(s.status)==="active");
    uniquePush(picked, stableSortByTime(pool, h), 7);
  }

  return picked.slice(0,7).map(s => ({ ...s, reason: reasonFor(s,h) }));
}
